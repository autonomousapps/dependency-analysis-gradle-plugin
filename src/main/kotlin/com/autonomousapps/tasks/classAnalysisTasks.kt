@file:Suppress("UnstableApiUsage")

package com.autonomousapps.tasks

import com.autonomousapps.TASK_GROUP_DEP
import com.autonomousapps.advice.VariantFile
import com.autonomousapps.internal.ClassSetReader
import com.autonomousapps.internal.JarReader
import com.autonomousapps.internal.utils.*
import org.gradle.api.DefaultTask
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.FileCollection
import org.gradle.api.file.FileSystemLocation
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.model.ObjectFactory
import org.gradle.api.provider.SetProperty
import org.gradle.api.tasks.*
import org.gradle.workers.WorkAction
import org.gradle.workers.WorkParameters
import org.gradle.workers.WorkerExecutor
import java.io.File
import javax.inject.Inject

abstract class ClassAnalysisTask(private val objects: ObjectFactory) : DefaultTask() {

  @get:Input
  abstract val variantFiles: SetProperty<VariantFile>

  /**
   * Java source files. Stubs generated by the kotlin-kapt plugin.
   */
  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFiles
  abstract val kaptJavaStubs: ConfigurableFileCollection

  /**
   * Android layout XML files.
   */
  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFiles
  abstract val layoutFiles: ConfigurableFileCollection

  /**
   * Files from test source-sets (src/test).
   */
  @get:Optional
  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFiles
  abstract val testJavaClassesDir: DirectoryProperty

  /**
   * Files from test source-sets (src/test).
   */
  @get:Optional
  @get:PathSensitive(PathSensitivity.RELATIVE)
  @get:InputFiles
  abstract val testKotlinClassesDir: DirectoryProperty

  @get:OutputFile
  abstract val output: RegularFileProperty

  @get:OutputFile
  abstract val outputPretty: RegularFileProperty

  internal fun layouts(files: List<File>) {
    for (file in files) {
      layoutFiles.from(
        objects.fileTree().from(file)
          .matching {
            include { it.path.contains("layout") }
          }.files
      )
    }
  }
}

fun getTestFiles(
  testJavaClassesDir: DirectoryProperty,
  testKotlinClassesDir: DirectoryProperty
): Set<File> {
  val testJavaClasses = testJavaClassesDir.orNull?.asFileTree?.files ?: emptySet()
  val testKtClasses = testKotlinClassesDir.orNull?.asFileTree?.files ?: emptySet()
  return testJavaClasses + testKtClasses
}

/**
 * Produces a report of all classes referenced by a given jar.
 */
@CacheableTask
abstract class JarAnalysisTask @Inject constructor(
  objects: ObjectFactory,
  private val workerExecutor: WorkerExecutor
) : ClassAnalysisTask(objects) {

  init {
    group = TASK_GROUP_DEP
    description = "Produces a report of all classes referenced by a given jar"
  }

  @get:Classpath
  abstract val jar: RegularFileProperty

  @TaskAction fun action() {
    // Output
    val reportFile = output
    val reportPrettyFile = outputPretty

    val jarFile = jar
    logger.debug("jar path = ${jarFile.get().asFile.path}")

    workerExecutor.noIsolation().submit(JarAnalysisWorkAction::class.java) {
      variantFiles.set(this@JarAnalysisTask.variantFiles)
      jar = jarFile
      kaptJavaSource = kaptJavaStubs
      layouts = layoutFiles
      testJavaClassesDir = this@JarAnalysisTask.testJavaClassesDir
      testKotlinClassesDir = this@JarAnalysisTask.testKotlinClassesDir
      report = reportFile
      reportPretty = reportPrettyFile
    }
  }
}

interface JarAnalysisParameters : WorkParameters {
  val variantFiles: SetProperty<VariantFile>
  var jar: RegularFileProperty
  var kaptJavaSource: FileCollection
  var layouts: FileCollection
  var testJavaClassesDir: DirectoryProperty
  var testKotlinClassesDir: DirectoryProperty
  var report: RegularFileProperty
  var reportPretty: RegularFileProperty
}

abstract class JarAnalysisWorkAction : WorkAction<JarAnalysisParameters> {

  private val logger = getLogger<JarAnalysisTask>()

  override fun execute() {
    val testFiles = getTestFiles(parameters.testJavaClassesDir, parameters.testKotlinClassesDir)
    val classNames = JarReader(
      variantFiles = parameters.variantFiles.get(),
      jarFile = parameters.jar.get().asFile,
      layouts = parameters.layouts.files,
      testFiles = testFiles,
      kaptJavaSource = parameters.kaptJavaSource.files
    ).analyze()

    parameters.report.getAndDelete().writeText(classNames.toJson())
    parameters.reportPretty.getAndDelete().writeText(classNames.toPrettyString())

    logger.log("Report:\n${parameters.report.get().asFile.readText()}")
  }
}

/**
 * Produces a report of all classes referenced by a given set of class files.
 */
@CacheableTask
abstract class ClassListAnalysisTask @Inject constructor(
  objects: ObjectFactory,
  private val workerExecutor: WorkerExecutor
) : ClassAnalysisTask(objects) {

  init {
    group = TASK_GROUP_DEP
    description = "Produces a report of all classes referenced by a given set of class files"
  }

  /**
   * Class files generated by Kotlin source. May be empty.
   */
  @get:Classpath
  @get:InputFiles
  abstract val kotlinClasses: ConfigurableFileCollection

  /**
   * Class files generated by Java source. May be empty.
   */
  @get:Classpath
  @get:InputFiles
  abstract val javaClasses: ConfigurableFileCollection

  @TaskAction fun action() {
    // Output
    val reportFile = output
    val reportPrettyFile = outputPretty

    val inputClassFiles = project.objects.setProperty(FileSystemLocation::class.java)
    javaClasses.elements.map {
      inputClassFiles.addAll(it.filter { fsl ->
        fsl.asFile.isFile && fsl.asFile.name.endsWith(".class")
      })
    }
    kotlinClasses.elements.map {
      inputClassFiles.addAll(it.filter { fsl ->
        fsl.asFile.isFile && fsl.asFile.name.endsWith(".class")
      })
    }


    logger.log("Java class files:${javaClasses.joinToString(prefix = "\n- ", separator = "\n- ") { it.path }}")
    logger.log("Kotlin class files:${kotlinClasses.joinToString(prefix = "\n- ", separator = "\n- ") { it.path }}")

    workerExecutor.noIsolation().submit(ClassListAnalysisWorkAction::class.java) {
      classes = inputClassFiles
      variantFiles.set(this@ClassListAnalysisTask.variantFiles)
      kaptJavaSource = kaptJavaStubs
      layouts = layoutFiles
      testJavaClassesDir = this@ClassListAnalysisTask.testJavaClassesDir
      testKotlinClassesDir = this@ClassListAnalysisTask.testKotlinClassesDir
      report = reportFile
      reportPretty = reportPrettyFile
    }
  }
}

interface ClassListAnalysisParameters : WorkParameters {
  var classes: SetProperty<FileSystemLocation>
  val variantFiles: SetProperty<VariantFile>
  var kaptJavaSource: FileCollection
  var layouts: FileCollection
  var testJavaClassesDir: DirectoryProperty
  var testKotlinClassesDir: DirectoryProperty
  var report: RegularFileProperty
  var reportPretty: RegularFileProperty
}

abstract class ClassListAnalysisWorkAction : WorkAction<ClassListAnalysisParameters> {

  private val logger = getLogger<ClassListAnalysisTask>()

  override fun execute() {
    val testFiles = getTestFiles(parameters.testJavaClassesDir, parameters.testKotlinClassesDir)
    val usedClasses = ClassSetReader(
      classes = parameters.classes.orNull?.map { it.asFile }?.toSet() ?: emptySet(),
      variantFiles = parameters.variantFiles.get(),
      layouts = parameters.layouts.files,
      kaptJavaSource = parameters.kaptJavaSource.files,
      testFiles = testFiles
    ).analyze()

    parameters.report.getAndDelete().writeText(usedClasses.toJson())
    parameters.reportPretty.getAndDelete().writeText(usedClasses.toPrettyString())

    logger.log("Class list usage report: ${parameters.report.get().asFile.path}")
  }
}
